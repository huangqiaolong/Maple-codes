BM := proc (s, N, P, x) local C, B, T, L, k, i, n, d, b, safemod; ASSERT(nops(s) = 2*N); safemod := proc (exp, P) options operator, arrow; `if`(P = 0, exp, `mod`(exp, P)) end proc; B := 1; C := 1; L := 0; k := 1; b := 1; for n from 0 to 2*N-1 do d := s[n+1]; for i to L do d := safemod(evala(d+coeff(C, x^i)*s[n-i+1]), P) end do; if d = 0 then k := k+1 end if; if d <> 0 and n < 2*L then C := safemod(expand(evala(C-d*x^k*B/b)), P); k := k+1 end if; if d <> 0 and 2*L <= n then T := C; C := safemod(expand(evala(C-d*x^k*B/b)), P); B := T; L := n+1-L; k := 1; b := d end if end do; return C end proc; Vinvert := proc (c, v::list, a::list, p)::list; local i, n, c1, d, q, q1, q2; n := degree(c, z); d := 0; q1 := 0; c1 := []; for i to n do d := d+a[i]*z^(n+1-i) end do; q := `mod`(evala(c*d), p); for i to n do q1 := q1+coeff(q, z, 2*n+1-i)*z^(n-i) end do; q2 := diff(c, z); for i to n do c1 := [op(c1), `mod`(evala((eval(q1, z = v[i]))/((eval(q2, z = v[i]))*v[i])), p)] end do; return c1 end proc;

;

MC := proc (a::list, p)::anything; local a1, v, u, n, q, f, m, i, c, q1, M, A; n := (1/2)*nops(a); u := []; v := []; q := []; f := BM(a, n, p, x); m := degree(f); a1 := z^m; for i to m do a1 := a1+coeff(f, x, i)*z^(m-i) end do; q1 := `mod`(Roots(a1), p); for i to m do q := [op(q), a[i]] end do; for i to m do v := [op(v), q1[i, 1]] end do; if 1 < m then c := Vinvert(a1, v, q, p) else return [[`mod`(evala(a[1]/v[1]), p), v[1]]] end if; A := []; for i to m do A := [op(A), degree(c[i], gamma)] end do; M := max(op(A)); A := []; for i to m do A := [op(A), [Myexponent(c[i], M), i]] end do; A := sort(A); u := []; for i to m do u := [op(u), [c[A[i, 2]], v[A[i, 2]]]] end do; return u end proc;

;

Myexponent := proc (u, m::integer) local i, A; A := []; for i from 0 to m do A := [coeff(u, gamma, i), op(A)] end do; return A end proc; Myeval := proc (f, n, alpha, p) local i, t, u, V, j, M, C, C1, a, b, c; t := nops(f); V := Matrix(t, 1); for i to t do u := 1; for j to n do u := `mod`(evala(u*alpha[j]^degree(op(i, f), x[j])), p) end do; V[i, 1] := u end do; M := Transpose(`mod`(VandermondeMatrix(V), p)); C := []; for i to t do C := [op(C), coeffs(op(i, f))] end do; C1 := Matrix(t, 1); for i to t do C1[i, 1] := C[i] end do; a := `mod`(M.C1, p); for i to t do u := `mod`(evala(V[i, 1]^t), p); for j to t do M[j, i] := `mod`(evala(M[j, i]*u), p) end do end do; b := `mod`(evala(M.C1), p); c := Matrix(1, 2*t); for i to t do c[1, i] := a[i, 1]; c[1, i+t] := b[i, 1] end do; return c end proc; mypower := proc (j, n, alpha, p) local i, beta; beta := []; for i to n do beta := [op(beta), `mod`(evala(alpha[i]^j), p)] end do; return beta end proc; myrandom := proc (p, k) local i, u; u := 0; for i from 0 to k-1 do u := u+RandomTools[Generate](integer(range = 0 .. p-1))*gamma^i end do; return u end proc; MBOT := proc (M, n, T, d, omega, zeta, p)::anything; local N, a, j, t, c, i, E, r, f, u, c1; a := []; for j to 2*T do a := [op(a), M[1, j]] end do; a := MC(a, p); t := nops(a); c := []; for i to t do c := [op(c), a[i, 1]] end do; N := Matrix(n+1, t); for j to t do N[1, j] := N[1, j]+a[j, 2] end do; for i from 2 to n+1 do a := []; for j to 2*T do a := [op(a), M[i, j]] end do; a := MC(a, p); if nops(a) <> t then return failure end if; for j to t do if a[j, 1] <> c[j] then return failure end if; N[i, j] := a[j, 2] end do end do; E := Matrix(n, t); for i to n do for j to t do r := `mod`(evala(N[i+1, j]/N[1, j]), p); E[i, j] := mylog(omega, r, d, p) end do end do; f := 0; for i to t do u := 1; c1 := c[i]; for j to n do u := u*x[j]^E[j, i]; c1 := `mod`(evala(c1/zeta[j]^E[j, i]), p) end do; f := f+c1*u end do; return f end proc; myeval2 := proc (r, beta, mysigma, zeta, p) local i, u; u := r; for i to n do u := `mod`(evala(eval(u, x[i] = zeta[i]*(z*beta[i]+mysigma[i]))), p) end do end proc; rationalpoly := proc (n, p, d1, d2, t11, t22) local i, q1, q2, r, a, h, m, t1, k1, j, X; X := []; for i to n do X := [op(X), x[i]] end do; q1 := `mod`(randpoly(X, degree = d1, terms = t11), p); q2 := `mod`(randpoly(X, degree = d2, terms = t22), p); while `mod`(Gcd(q1, q2), p) <> 1 do q1 := `mod`(randpoly(X, degree = d1, terms = t11), p); q2 := `mod`(randpoly(X, degree = d2, terms = t22), p) end do; r := q1/q2; m := nops(q1); a := [[degree(op(1, q1)), 1]]; t1 := 1; for i from 2 to nops(q1) do k1 := 0; for j to nops(a) do if degree(op(i, q1)) = a[j, 1] then a := subsop(j = [a[j, 1], a[j, 2]+1], a); k1 := 1; break end if end do; if k1 <> 1 then a := [op(a), [degree(op(i, q1)), 1]]; k1 := 0 end if end do; for i to nops(a) do if t1 < a[i, 2] then t1 := a[i, 2] end if end do; m := nops(q2); a := [[degree(op(1, q2)), 1]]; for i from 2 to nops(q2) do k1 := 0; for j to nops(a) do if degree(op(i, q2)) = a[j, 1] then a := subsop(j = [a[j, 1], a[j, 2]+1], a); k1 := 1; break end if end do; if k1 <> 1 then a := [op(a), [degree(op(i, q2)), 1]]; k1 := 0 end if end do; for i to nops(a) do if t1 < a[i, 2] then t1 := a[i, 2] end if end do; return [r, t1] end proc; mylog := proc (A, B, d, p) local i, m, W, S, u, v, q1, q2; m := ceil(sqrt(d)); W := [B]; u := `mod`(evala(A^m), p); S := [u]; for i to m do W := [op(W), `mod`(evala(W[i]*A), p)] end do; for i to m-1 do S := [op(S), `mod`(evala(S[i]*u), p)] end do; v := op(`intersect`({op(W)}, {op(S)})); if nops([v]) <> 1 then v := [v][1] end if; for i to m+1 do if W[i] = v then q1 := i-1; break end if end do; for i to m do if S[i] = v then q2 := i; break end if end do; return q2*m-q1 end proc; mypade := proc (a, b, d, e, p) local i, h0, h1, h2, g0, g1, g2, c, q1, c1, st; h1 := `mod`(Interp(b, a, x), p); h0 := 1; for i to d+e+1 do h0 := `mod`(Expand(h0*(x-b[i])), p) end do; g0 := 0; g1 := 1; while d < degree(h1) do h2 := h1; h1 := `mod`(Rem(h0, h1, x, 'q1'), p); h0 := h2; g2 := g1; g1 := `mod`(Expand(g0-q1*g1), p); g0 := g2 end do; if coeff(g1, x, 0) <> 0 then g0 := coeff(g1, x, 0) else g0 := coeff(h1, x, 0) end if; return [`mod`(evala(h1/g0), p), `mod`(evala(g1/g0), p)] end proc;


myrationaleval := proc (r, n, d, e, T1, P, alpha, zeta, mysigma, omega) local A, s, i, j, alphaomega, h, B, f, g; s := nops(P); f := numer(r); g := denom(r); for i from 0 to n do A[i] := Matrix(2*T1, s) end do; for i to 2*T1 do for j to s do A[0][i, j] := `mod`(evala((`mod`(evala(eval(myeval2(f, mypower(i, n, alpha, p), mysigma, zeta, p), z = P[j])), p))/(`mod`(evala(eval(myeval2(g, mypower(i, n, alpha, p), mysigma, zeta, p), z = P[j])), p))), p) end do end do; for j to n do alphaomega := subsop(j = `mod`(evala(alpha[j]*omega), p), alpha); for i to 2*T1 do for h to s do A[j][i, h] := `mod`(evala((`mod`(evala(eval(myeval2(f, mypower(i, n, alphaomega, p), mysigma, zeta, p), z = P[h])), p))/(`mod`(evala(eval(myeval2(g, mypower(i, n, alphaomega, p), mysigma, zeta, p), z = P[h])), p))), p) end do end do end do; B := []; for i from 0 to n do B := [op(B), A[i]] end do; return B end proc;

myLeadCoeff := proc (n, B, d, e, P, T1, alpha, zeta, omega, p) local i, a, b, M, h, u, j; M := Matrix(n+1, 2*T1); for i to 2*T1 do b := []; for h to d+e+1 do b := [op(b), B[1][i, h]] end do; u := mypade(b, P, d, e, p)[2]; M[1, i] := `mod`(evala(lcoeff(u, x)/coeff(u, x, 0)), p) end do; for j to n do for i to 2*T1 do b := []; for h to d+e+1 do b := [op(b), B[j+1][i, h]] end do; u := mypade(b, P, d, e, p)[2]; M[j+1, i] := `mod`(evala(lcoeff(u, x)/coeff(u, x, 0)), p) end do end do; return M end proc; mydegree := proc (f, d) local i, E; E := []; for i from d by -1 to 0 do if coeff(f, x, i) <> 0 then E := [op(E), i] end if end do; return E end proc; mycoeffs := proc (f, E, p) local i, C, j; C := []; j := nops(E); for i to j do C := [op(C), `mod`(evala(coeff(f, x, E[i])), p)] end do; return C end proc; myRatInt := proc (n, B, B1, d, e, P, T1, alpha, zeta, omega, p) local i, a, b, M, h, u, j, u1, u2, C1, C2, k1, k2, Q1, Q2, f, g, E1, E2; M := myLeadCoeff(n, B, d, e, P, T1, alpha, zeta, omega, p); b := []; for h to d+e+1 do b := [op(b), B1[1][1, h]] end do; u := mypade(b, P, d, e, p); u1 := u[1]; u2 := u[2]; u1 := (`mod`(evala(M[1, 1]/lcoeff(u2, x)), p))*u1; u2 := (`mod`(evala(M[1, 1]/lcoeff(u2, x)), p))*u2; E1 := mydegree(u1, d); E2 := mydegree(u2, e); C1 := mycoeffs(u1, E1, p); C2 := mycoeffs(u2, E2, p); k1 := nops(C1); k2 := nops(C2); for i to k1 do Q1[i] := Matrix(n+1, 2*T1) end do; for i to k2 do Q2[i] := Matrix(n+1, 2*T1) end do; for i to k1 do Q1[i][1, 1] := C1[i] end do; for i to k2 do Q2[i][1, 1] := C2[i] end do; for i from 2 to 2*T1 do b := []; for h to d+e+1 do b := [op(b), B1[1][i, h]] end do; u := mypade(b, P, d, e, p); u1 := u[1]; u2 := u[2]; u1 := `mod`(evala(M[1, i]*u1/lcoeff(u2, x)), p); u2 := `mod`(evala(M[1, i]*u2/lcoeff(u2, x)), p); C1 := mycoeffs(u1, E1, p); C2 := mycoeffs(u2, E2, p); for h to k1 do Q1[h][1, i] := C1[h] end do; for h to k2 do Q2[h][1, i] := C2[h] end do end do; for j to n do for i to 2*T1 do b := []; for h to d+e+1 do b := [op(b), B1[j+1][i, h]] end do; u := mypade(b, P, d, e, p); u1 := u[1]; u2 := u[2]; u1 := `mod`(evala(M[j+1, i]*u1/lcoeff(u2, x)), p); u2 := `mod`(evala(M[j+1, i]*u2/lcoeff(u2, x)), p); C1 := mycoeffs(u1, E1, p); C2 := mycoeffs(u2, E2, p); for h to k1 do Q1[h][j+1, i] := C1[h] end do; for h to k2 do Q2[h][j+1, i] := C2[h] end do end do end do; f := 0; for i to k1 do f := f+MBOT(Q1[i], n, T1, d, omega, zeta, p) end do; g := 0; for i to k2 do g := g+MBOT(Q2[i], n, T1, e, omega, zeta, p) end do; return [`mod`(Expand(`mod`(evala(f/lcoeff(f)), p)), p), `mod`(Expand(`mod`(evala(g/lcoeff(f)), p)), p)] end proc;
